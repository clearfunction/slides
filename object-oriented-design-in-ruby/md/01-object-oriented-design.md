## Object-Oriented Design

_viewing the world as a series of spontaneous interactions between objects_

<..>

## A Way to View the World

* Not a collection of predefined procedures
* Series of messages that pass between objects
* With this perspective, the rest is just natural!

<..>

## Design Solves Problems

* It doesn't have to be productivity versus happiness
* Change is a constant in development
* Because change is unavoidable, design matters
* Applications that are easy to change are a joy to write

The Goal: _Flexible & Adaptable_ Apps

<..>

## Defining Design

* Every application is a collection of code
* The code's arrangement is the _design_.

[art gif]

Design is the art of arranging code.

The purpose of design is to allow us to do design _later_.

ðŸ’¸ _The primary goal is reducing the cost of change._ ðŸ’¸

<..>

## Let the Controversy Begin

"Agile believes that your customers can't define the software they want before seeing it, so it's best to show them sooner rather than later. If this premise is true, then it logically follows that you should build software in tiny increments, gradually iterating your way into an application that meets the customer's true need."

"If Agile is correct, two other things are also true. First, there is absolutely no point in doing a Big Up Front Design (BUFD) (because it cannot possibly be correct), and second, no one can predict when the application will be done (because you don't know in advance what it will eventually do)."

(discuss)

<..>

## ðŸš¨ðŸš¨ðŸš¨ WARNING! ðŸš¨ðŸš¨ðŸš¨

[this slide needs an image]

* Successful but _undesigned_ applications carry the seeds of their own destruction; they are easy to write but gradually become impossible to change.
* If you cannot write well-designed code you'll have to rewrite your application during every iteration.
* You must do the best you can in the time you have.
* When the act of design prevents software from being delivered on time, you have lost.

<..>

## Intro to OOD

[this slide needs an image]

* Objects have behavior and may contain data, data to which tehy alone control access.
* Objects invoke one another's behavior by sending each other _messages_.
* Every object decides for itself how much, or how little, of its data to expose.
* Objects have _types_ which tell other objects what messages they respond to.
* OO languages allow you to create new types of your own!
